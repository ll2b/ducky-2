{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ducky.js","src/ducky-0-version.js","src/ducky-3-select-3-api.js","src/ducky-4-validate-4-api.js","src/ducky-5-params.js","src/ducky-2-registry-2-api.js","src/ducky-3-select-1-compile.js","src/ducky-3-select-2-execute.js","src/ducky-4-validate-2-parse.js","src/ducky-4-validate-3-execute.js","src/ducky-4-validate-1-tokenize.js","src/ducky-2-registry-1-data.js","src/ducky-1-util.js"],"names":["_ducky0Version","require","_ducky2Registry2Api","_ducky3Select3Api","_ducky4Validate4Api","_ducky5Params","module","exports","version","register","unregister","select","validate","params","major","minor","micro","date","_ducky3Select1Compile","_ducky3Select2Execute","select_cache","obj","spec","value","arguments","length","Error","path","select_compile","select_execute","compile","apply","undefined","execute","_typeof","Array","_ducky4Validate1Tokenize","_ducky4Validate2Parse","_ducky4Validate3Execute","validate_cache","errors","ast","token","validate_tokenize","validate_parse","parse","validate_execute","exec_spec","params_is_name_based","args","name_based","name","Object","hasOwnProperty","call","params_check_validity","func","param","valid","what","JSON","stringify","def","req","positional","required","pos2name","pos","i","rest","push","_ducky2Registry1Data","type","registry","registered","m","txt","match","replace","substr","value_old","value_new","splice","parseInt","len","this","parse_spec","symbol","peek","ctx","parse_not","parse_group","parse_hash","parse_array","parse_primary","parse_any","parse_class","consume","op","child","op1","op2","elements","key","parse_key","arity","parse_arity","element","skip","primary","any","clazz","charset","Number","MAX_VALUE","indexOf","c","errCtx","msg","node","exec_not","exec_or","exec_hash","exec_array","exec_primary","exec_class","err","forEach","e","err1","_ref2","err2","valid1","valid2","el","fields","field","hasAnyKeys","propertyIsEnumerable","sep","found","prototype","toString","_ducky1Util","Token","setName","setText","b","addToken","std_types","global","text","tokens","b1","b2","e2","e1","offset","width","tok","context","k","Math","floor","str","k1","k2"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\r\n**  Ducky -- Duck-Typed Value Handling for JavaScript\r\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\r\n**\r\n**  Permission is hereby granted, free of charge, to any person obtaining\r\n**  a copy of this software and associated documentation files (the\r\n**  \"Software\"), to deal in the Software without restriction, including\r\n**  without limitation the rights to use, copy, modify, merge, publish,\r\n**  distribute, sublicense, and/or sell copies of the Software, and to\r\n**  permit persons to whom the Software is furnished to do so, subject to\r\n**  the following conditions:\r\n**\r\n**  The above copyright notice and this permission notice shall be included\r\n**  in all copies or substantial portions of the Software.\r\n**\r\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\nimport { version              } from \"./ducky-0-version.js\"\r\nimport { register, unregister } from \"./ducky-2-registry-2-api.js\"\r\nimport { select               } from \"./ducky-3-select-3-api.js\"\r\nimport { validate             } from \"./ducky-4-validate-4-api.js\"\r\nimport { params               } from \"./ducky-5-params.js\"\r\n\r\nmodule.exports = {\r\n    version,\r\n    register,\r\n    unregister,\r\n    select,\r\n    validate,\r\n    params\r\n}\r\n\r\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global 2: false */\n/* global 4: false */\n/* global 0: false */\n/* global 20160313:  false */\n\n/*  API version  */\nvar version = {\n    major: 2,\n    minor: 4,\n    micro: 0,\n    date:  20160313\n}\n\nexport { version }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { select_compile } from \"./ducky-3-select-1-compile.js\"\nimport { select_execute } from \"./ducky-3-select-2-execute.js\"\n\n/*  the internal compile cache  */\nlet select_cache = {}\n\n/*  API function: select an arbitrary value via a path specification\n    and either get the current value or set the new value  */\nvar select = function (obj, spec, value) {\n    /*  sanity check arguments  */\n    if (arguments.length < 2)\n        throw new Error(`select: invalid number of arguments: ${arguments.length} (minimum of 2 expected)`)\n    else if (arguments.length > 3)\n        throw new Error(`select: invalid number of arguments: ${arguments.length} (maximum of 3 expected)`)\n    if (typeof spec !== \"string\")\n        throw new Error(`select: invalid specification argument: \"${spec}\" (string expected)`)\n\n    /*  compile select path from specification\n        or reuse cached pre-compiled selection path  */\n    let path = select_cache[spec]\n    if (typeof path === \"undefined\") {\n        path = select_compile(spec)\n        select_cache[spec] = path\n    }\n\n    /*  execute the object selection  */\n    return (\n          arguments.length === 2\n        ? select_execute(obj, path)\n        : select_execute(obj, path, value)\n    )\n}\n\n/*  compile a path specification into array of dereferencing steps  */\nselect.compile = function (spec) {\n    /*  sanity check argument  */\n    if (arguments.length !== 1)\n        throw new Error(`select: invalid number of arguments: ${arguments.length} (exactly 1 expected)`)\n    if (typeof spec !== \"string\")\n        throw new Error(`select: invalid specification argument: \"${spec}\" (string expected)`)\n    return select_compile.apply(undefined, arguments)\n}\n\n/*  execute object selection  */\nselect.execute = function (obj, path) {\n    /*  sanity check arguments  */\n    if (arguments.length < 2)\n        throw new Error(`select: invalid number of arguments: ${arguments.length} (minimum of 2 expected)`)\n    else if (arguments.length > 3)\n        throw new Error(`select: invalid number of arguments: ${arguments.length} (maximum of 3 expected)`)\n    if (!(typeof path === \"object\" && path instanceof Array))\n        throw new Error(`select: invalid path argument: \"${path}\" (array expected)`)\n    return select_execute.apply(undefined, arguments)\n}\n\nexport { select }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { validate_tokenize } from \"./ducky-4-validate-1-tokenize.js\"\nimport { validate_parse    } from \"./ducky-4-validate-2-parse.js\"\nimport { validate_execute  } from \"./ducky-4-validate-3-execute.js\"\n\n/*  internal compile cache  */\nlet validate_cache = {}\n\n/*  API function: validate an arbitrary value against a validation DSL  */\nvar validate = function (value, spec, errors) {\n    /*  sanity check arguments  */\n    if (arguments.length < 2)\n        throw new Error(`validate: invalid number of arguments: ${arguments.length} (minimum of 2 expected)`)\n    else if (arguments.length > 3)\n        throw new Error(`validate: invalid number of arguments: ${arguments.length} (maximum of 3 expected)`)\n    if (typeof spec !== \"string\")\n        throw new Error(`validate: invalid specification argument: \"${spec}\" (string expected)`)\n\n    /*  compile validation AST from specification\n        or reuse cached pre-compiled validation AST  */\n    var ast = validate_cache[spec]\n    if (typeof ast === \"undefined\") {\n        ast = validate.compile(spec)\n        validate_cache[spec] = ast\n    }\n\n    /*  execute validation AST against the value  */\n    return validate.execute(value, ast, errors)\n}\n\nvalidate.compile = function (spec) {\n    /*  sanity check arguments  */\n    if (arguments.length !== 1)\n        throw new Error(`validate: invalid number of arguments: ${arguments.length} (exactly 1 expected)`)\n    if (typeof spec !== \"string\")\n        throw new Error(`validate: invalid specification argument: \"${spec}\" (string expected)`)\n\n    /*  tokenize the specification string into a token stream */\n    var token = validate_tokenize(spec)\n\n    /*  parse the token stream into an AST  */\n    var ast = validate_parse.parse(token)\n\n    return ast\n}\n\nvalidate.execute = function (value, ast, errors) {\n    /*  sanity check arguments  */\n    if (arguments.length < 2)\n        throw new Error(`validate: invalid number of arguments: ${arguments.length} (minimum of 2 expected)`)\n    else if (arguments.length > 3)\n        throw new Error(`validate: invalid number of arguments: ${arguments.length} (maximum of 3 expected)`)\n    if (arguments.length < 3 || typeof errors === \"undefined\")\n        errors = null\n\n    /*  execute validation AST against the value  */\n    return validate_execute.exec_spec(value, ast, \"\", errors)\n}\n\nexport { validate }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { validate } from \"./ducky-4-validate-4-api.js\"\n\n/*  determine or at least guess whether we were called with\n    positional or name-based parameters  */\nlet params_is_name_based = function (args, spec) {\n    let name_based = false\n    if (   args.length === 1\n        && typeof args[0] === \"object\") {\n        /*  ok, looks like a regular call like\n            \"foo({ foo: ..., bar: ...})\"  */\n        name_based = true\n\n        /*  ...but do not be mislead by a positional use like\n            \"foo(bar)\" where \"bar\" is an arbitrary object!  */\n        for (let name in args[0]) {\n            if (!Object.hasOwnProperty.call(args[0], name)) {\n                if (typeof spec[name] === \"undefined\")\n                    name_based = false\n            }\n        }\n    }\n    return name_based\n}\n\n/*  common value validity checking  */\nlet params_check_validity = function (func, param, value, valid, what) {\n    if (typeof valid === \"undefined\")\n        return\n    if (!validate(value, valid))\n        throw new Error(`${func}: parameter \"${param}\" has ` +\n            `${what} ${JSON.stringify(value)}, which does not validate against \"${valid}\"`)\n}\n\n/*  API function: flexible parameter handling  */\nvar params = function (func, args, spec) {\n    /*  start with a fresh parameter object  */\n    var params = {}\n\n    /*  handle parameter defaults  */\n    let name\n    for (name in spec) {\n        if (!Object.hasOwnProperty.call(spec, name))\n            continue\n        if (typeof spec[name].def !== \"undefined\") {\n            if (typeof spec[name].valid !== \"undefined\")\n                params_check_validity(func, name, spec[name].def, spec[name].valid, \"default value\")\n            params[name] = spec[name].def\n        }\n    }\n\n    /*  process parameters  */\n    if (params_is_name_based(args, spec)) {\n        args = args[0]\n\n        /*\n         *  case 1: name-based parameter specification\n         */\n\n        /*  pass 1: check for unknown but extra parameters  */\n        for (name in args) {\n            if (!Object.hasOwnProperty.call(args, name))\n                continue\n            if (typeof spec[name] === \"undefined\")\n                throw new Error(`${func}: unknown parameter \"${name}\"`)\n            params_check_validity(func, name, args[name], spec[name].valid, \"value\")\n            params[name] = args[name]\n        }\n\n        /*  pass 2: check for required but missing parameters  */\n        for (name in spec) {\n            if (!Object.hasOwnProperty.call(spec, name))\n                continue\n            if (   typeof spec[name].req !== \"undefined\"\n                && spec[name].req\n                && typeof args[name] === \"undefined\")\n                throw new Error(`${func}: required parameter \"${name}\" missing`)\n        }\n    }\n    else {\n        /*\n         *  case 2: positional parameter specification\n         */\n\n        /*  pass 1: determine number of positional and total required parameters\n            and the mapping from parameter position to parameter name  */\n        let positional = 0\n        let required = 0\n        let pos2name = {}\n        for (name in spec) {\n            if (!Object.hasOwnProperty.call(spec, name))\n                continue\n            if (typeof spec[name].pos !== \"undefined\") {\n                pos2name[spec[name].pos] = name\n                if (typeof spec[name].pos === \"number\")\n                    positional++\n                if (typeof spec[name].req !== \"undefined\" && spec[name].req)\n                    required++\n            }\n        }\n\n        /*  check for required parameters  */\n        if (args.length < required)\n            throw new Error(`${func}: invalid number of arguments (at least ${required} required)`)\n\n        /*  pass 2: process parameters in sequence  */\n        let i = 0\n        while (i < positional && i < args.length) {\n            params_check_validity(func, pos2name[i], args[i], spec[pos2name[i]].valid, \"value\")\n            params[pos2name[i]] = args[i]\n            i++\n        }\n        if (i < args.length) {\n            if (typeof pos2name[\"...\"] === \"undefined\")\n                throw new Error(`${func}: too many arguments provided`)\n            let rest = []\n            while (i < args.length)\n                rest.push(args[i++])\n            params_check_validity(func, pos2name[\"...\"], rest, spec[pos2name[\"...\"]].valid, \"value\")\n            params[pos2name[\"...\"]] = rest\n        }\n    }\n\n    /*  return prepared parameter object  */\n    return params\n}\n\nexport { params }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { registry } from \"./ducky-2-registry-1-data.js\"\n\n/*  API function: register a type under a name  */\nvar register = function (name, type) {\n    /*  sanity check arguments  */\n    if (arguments.length !== 2)\n        throw new Error(`register: invalid number of arguments: ${arguments.length} (exactly 2 expected)`)\n    if (typeof name !== \"string\")\n        throw new Error(`register: invalid name argument: \"${name}\" (string expected)`)\n    if (typeof type !== \"function\")\n        throw new Error(`register: invalid type argument: \"${type}\" (function object expected)`)\n    if (typeof registry[name] !== \"undefined\")\n        throw new Error(`register: type already registered under name: \"${name}\"`)\n\n    /*  add type to registry  */\n    registry[name] = type\n}\n\n/*  API function: unregister a type under a name  */\nvar unregister = function (name) {\n    /*  sanity check arguments  */\n    if (arguments.length !== 1)\n        throw new Error(`unregister: invalid number of arguments: ${arguments.length} (exactly 1 expected)`)\n    if (typeof name !== \"string\")\n        throw new Error(`unregister: invalid name argument: \"${name}\" (string expected)`)\n    if (typeof registry[name] === \"undefined\")\n        throw new Error(`unregister: no type registered under name: \"${name}\"`)\n\n    /*  delete type from registry  */\n    delete registry[name]\n}\n\n/*  API function: check for registered type under a name  */\nvar registered = function (name) {\n    /*  sanity check arguments  */\n    if (arguments.length !== 1)\n        throw new Error(`registered: invalid number of arguments: ${arguments.length} (exactly 1 expected)`)\n    if (typeof name !== \"string\")\n        throw new Error(`registered: invalid name argument: \"${name}\" (string expected)`)\n    return registry[name]\n}\n\nexport { registered, register, unregister }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar select_compile = function (spec) {\n    /*  result and state variables  */\n    let path = []\n    let pos = 0\n\n    /*  iterate over selection specification  */\n    let m\n    let txt = spec\n    while (txt !== \"\") {\n        /*  case 1: standard path segment  */\n        if ((m = txt.match(/^\\s*(?:\\.)?\\s*([a-zA-Z$0-9_][a-zA-Z$0-9_:-]*)/)) !== null)\n            path.push(m[1])\n        /*  case 2: numerical array-style dereference  */\n        else if ((m = txt.match(/^\\s*\\[\\s*(\\d+|\\*{1,2})\\s*\\]/)) !== null)\n            path.push(m[1])\n        /*  case 3: double-quoted string array-style dereference  */\n        else if ((m = txt.match(/^\\s*\\[\\s*\"((?:\\\\\"|.)*?)\"\\s*\\]/)) !== null)\n            path.push(m[1].replace(/\\\\\"/g, \"\\\"\"))\n        /*  case 4: single-quoted string array-style dereference  */\n        else if ((m = txt.match(/^\\s*\\[\\s*'((?:\\\\'|.)*?)'\\s*\\]/)) !== null)\n            path.push(m[1].replace(/\\\\'/g, \"'\"))\n        /*  skip all whitespaces between segments  */\n        else if ((m = txt.match(/^\\s+$/)) !== null)\n            break\n        else\n            throw new Error(\"select: parse error: invalid character at: \" +\n                spec.substr(0, pos) + \"<\" + txt.substr(0, 1) + \">\" + txt.substr(1))\n\n        /*  advance parsing position  */\n        pos += m[0].length\n        txt = txt.substr(m[0].length)\n    }\n\n    return path\n}\n\nexport { select_compile }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  execute object selection  */\nvar select_execute = function (obj, path) {\n    /*  handle special case of empty path */\n    if (path.length === 0) {\n        if (arguments.length === 3)\n            throw new Error(\"select: cannot set value on empty path\")\n        else\n            return obj\n    }\n\n    /*  step into object graph according to path prefix  */\n    let i = 0\n    while (i < path.length - 1) {\n        if (typeof obj !== \"object\")\n            throw new Error(\"select: cannot further dereference: no more intermediate objects in path\")\n        obj = obj[path[i++]]\n    }\n\n    /*  get the old value  */\n    if (typeof obj !== \"object\")\n        throw new Error(\"select: cannot further dereference: no object at end of path\")\n    let value_old = obj[path[i]]\n\n    /*  optionally set new value  */\n    if (arguments.length === 3) {\n        let value_new = arguments[2]\n        if (value_new === undefined) {\n            /*  delete value from collection  */\n            if (obj instanceof Array)\n                obj.splice(parseInt(path[i], 10), 1)\n            else\n                delete obj[path[i]]\n        }\n        else\n            /*  set value into collection  */\n            obj[path[i]] = value_new\n    }\n\n    return value_old\n}\n\nexport { select_execute }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  parse specification  */\nvar validate_parse = {\n    parse (token) {\n        if (token.len <= 0)\n            return null\n        let ast = this.parse_spec(token)\n        let symbol = token.peek()\n        if (symbol !== null)\n            throw new Error(`validate: parse error: unexpected token (expected end-of-string): \"${token.ctx()}\"`)\n        return ast\n    },\n\n    /*  parse a specification  */\n    parse_spec (token) {\n        if (token.len <= 0)\n            return null\n        let ast\n        let symbol = token.peek()\n        if (symbol === \"!\")\n            ast = this.parse_not(token)\n        else if (symbol === \"(\")\n            ast = this.parse_group(token)\n        else if (symbol === \"{\")\n            ast = this.parse_hash(token)\n        else if (symbol === \"[\")\n            ast = this.parse_array(token)\n        else if (symbol.match(/^(?:null|undefined|boolean|number|string|function|object)$/))\n            ast = this.parse_primary(token)\n        else if (symbol === \"any\")\n            ast = this.parse_any(token)\n        else if (symbol.match(/^[_a-zA-Z$][_a-zA-Z$0-9]*(?:\\.[_a-zA-Z$][_a-zA-Z$0-9]*)*$/))\n            ast = this.parse_class(token)\n        else\n            throw new Error(`validate: parse error: invalid token symbol: \"${token.ctx()}\"`)\n        return ast\n    },\n\n    /*  parse boolean \"not\" operation  */\n    parse_not (token) {\n        token.consume(\"!\")\n        let ast = this.parse_spec(token) /*  RECURSION  */\n        ast = { type: \"not\", op: ast }\n        return ast\n    },\n\n    /*  parse group (for boolean \"or\" operation)  */\n    parse_group (token) {\n        token.consume(\"(\")\n        let ast = this.parse_spec(token)\n        while (token.peek() === \"|\") {\n            token.consume(\"|\")\n            let child = this.parse_spec(token) /*  RECURSION  */\n            ast = { type: \"or\", op1: ast, op2: child }\n        }\n        token.consume(\")\")\n        return ast\n    },\n\n    /*  parse hash type specification  */\n    parse_hash (token) {\n        token.consume(\"{\")\n        let elements = []\n        while (token.peek() !== \"}\") {\n            let key = this.parse_key(token)\n            let arity = this.parse_arity(token, \"?\")\n            token.consume(\":\")\n            let spec = this.parse_spec(token)  /*  RECURSION  */\n            elements.push({ type: \"element\", key: key, arity: arity, element: spec })\n            if (token.peek() === \",\")\n                token.skip()\n            else\n                break\n        }\n        let ast = { type: \"hash\", elements: elements }\n        token.consume(\"}\")\n        return ast\n    },\n\n    /*  parse array type specification  */\n    parse_array (token) {\n        token.consume(\"[\")\n        let elements = []\n        while (token.peek() !== \"]\") {\n            var spec = this.parse_spec(token)  /*  RECURSION  */\n            var arity = this.parse_arity(token, \"?*+\")\n            elements.push({ type: \"element\", element: spec, arity: arity })\n            if (token.peek() === \",\")\n                token.skip()\n            else\n                break\n        }\n        let ast = { type: \"array\", elements: elements }\n        token.consume(\"]\")\n        return ast\n    },\n\n    /*  parse primary type specification  */\n    parse_primary (token) {\n        let primary = token.peek()\n        if (!primary.match(/^(?:null|undefined|boolean|number|string|function|object)$/))\n            throw new Error(`validate: parse error: invalid primary type \"${primary}\"`)\n        token.skip()\n        return { type: \"primary\", name: primary }\n    },\n\n    /*  parse special \"any\" type specification  */\n    parse_any (token) {\n        let any = token.peek()\n        if (any !== \"any\")\n            throw new Error(`validate: parse error: invalid any type \"${any}\"`)\n        token.skip()\n        return { type: \"any\" }\n    },\n\n    /*  parse JavaScript class specification  */\n    parse_class (token) {\n        let clazz = token.peek()\n        if (!clazz.match(/^[_a-zA-Z$][_a-zA-Z$0-9]*(?:\\.[_a-zA-Z$][_a-zA-Z$0-9]*)*$/))\n            throw new Error(`validate: parse error: invalid class type \"${clazz}\"`)\n        token.skip()\n        return { type: \"class\", name: clazz }\n    },\n\n    /*  parse arity specification  */\n    parse_arity (token, charset) {\n        let arity = [ 1, 1 ]\n        if (   token.len >= 5\n            && token.peek(0) === \"{\"\n            && token.peek(1).match(/^[0-9]+$/)\n            && token.peek(2) === \",\"\n            && token.peek(3).match(/^(?:[0-9]+|oo)$/)\n            && token.peek(4) === \"}\"          ) {\n            arity = [\n                parseInt(token.peek(1), 10),\n                (  token.peek(3) === \"oo\"\n                 ? Number.MAX_VALUE\n                 : parseInt(token.peek(3), 10))\n            ]\n            token.skip(5)\n        }\n        else if (\n               token.len >= 1\n            && token.peek().length === 1\n            && charset.indexOf(token.peek()) >= 0) {\n            let c = token.peek()\n            switch (c) {\n                case \"?\": arity = [ 0, 1 ];                break\n                case \"*\": arity = [ 0, Number.MAX_VALUE ]; break\n                case \"+\": arity = [ 1, Number.MAX_VALUE ]; break\n            }\n            token.skip()\n        }\n        return arity\n    },\n\n    /*  parse hash key specification  */\n    parse_key (token) {\n        var key = token.peek()\n        if (!key.match(/^(?:[_a-zA-Z$][_a-zA-Z$0-9]*|@)$/))\n            throw new Error(`validate: parse error: invalid key \"${key}\"`)\n        token.skip()\n        return key\n    }\n}\n\nexport { validate_parse }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { registered } from \"./ducky-2-registry-2-api.js\"\n\n/*  provide a reasonable context information for error messages  */\nvar errCtx = (path, msg) => {\n    if (path === \"\")\n        return `mismatch at root-level: ${msg}`\n    else\n        return `mismatch at path \"${path}\": ${msg}`\n}\n\nvar validate_execute = {\n    /*  validate specification (top-level)  */\n    exec_spec (value, node, path, errors) {\n        let valid = false\n        if (node !== null) {\n            switch (node.type) {\n                case \"not\":     valid = this.exec_not(    value, node, path, errors); break\n                case \"or\":      valid = this.exec_or(     value, node, path, errors); break\n                case \"hash\":    valid = this.exec_hash(   value, node, path, errors); break\n                case \"array\":   valid = this.exec_array(  value, node, path, errors); break\n                case \"primary\": valid = this.exec_primary(value, node, path, errors); break\n                case \"class\":   valid = this.exec_class(  value, node, path, errors); break\n                case \"any\":     valid = true;                                         break\n                default:\n                    throw new Error(`validate: invalid validation AST: node has unknown type \"${node.type}\"`)\n            }\n        }\n        return valid\n    },\n\n    /*  validate through boolean \"not\" operation  */\n    exec_not (value, node, path, errors) {\n        let err = errors !== null ? [] : null\n        let valid = this.exec_spec(value, node.op, path, err)  /*  RECURSION  */\n        valid = !valid\n        if (!valid && errors !== null)\n            err.forEach((e) => errors.push(e))\n        return valid\n    },\n\n    /*  validate through boolean \"or\" operation  */\n    exec_or (value, node, path, errors) {\n        let [ err1, err2 ] = errors !== null ? [ [], [] ] : [ null, null ]\n        let valid1 = this.exec_spec(value, node.op1, path, err1)  /*  RECURSION  */\n        let valid2 = this.exec_spec(value, node.op2, path, err2)  /*  RECURSION  */\n        let valid = valid1 || valid2\n        if (!valid && errors !== null) {\n            err1.forEach((e) => errors.push(e))\n            err2.forEach((e) => errors.push(e))\n        }\n        return valid\n    },\n\n    /*  validate hash type  */\n    exec_hash (value, node, path, errors) {\n        let i, el\n        let valid = (typeof value === \"object\")\n        let fields = {}\n        let field\n        if (!valid && errors !== null)\n            errors.push(`mismatch at path \"${path}\": found type \"${typeof value}\", expected hash`)\n        else if (valid) {\n            /*  pass 1: ensure that all mandatory fields exist\n                and determine map of valid fields for pass 2  */\n            let hasAnyKeys = false\n            for (field in value) {\n                if (   !Object.hasOwnProperty.call(value, field)\n                    || !Object.propertyIsEnumerable.call(value, field)\n                    || field === \"constructor\"\n                    || field === \"prototype\"                          )\n                    continue\n                hasAnyKeys = true\n                break\n            }\n            for (i = 0; i < node.elements.length; i++) {\n                el = node.elements[i]\n                fields[el.key] = el.element\n                if (   el.arity[0] > 0\n                    && (   (el.key === \"@\" && !hasAnyKeys)\n                        || (el.key !== \"@\" && typeof value[el.key] === \"undefined\"))) {\n                    valid = false\n                    if (errors !== null) {\n                        if (el.key === \"@\")\n                            errors.push(errCtx(path, \"mandatory element under arbitrary key not found\"))\n                        else\n                            errors.push(errCtx(path, `mandatory element under key \"${el.key}\" not found`))\n                    }\n                    else\n                        break\n                }\n            }\n        }\n        if (valid || errors !== null) {\n            /*  pass 2: ensure that no unknown fields exist\n                and that all existing fields are valid  */\n            let sep = (path !== \"\" ? \".\" : \"\")\n            for (field in value) {\n                if (   !Object.hasOwnProperty.call(value, field)\n                    || !Object.propertyIsEnumerable.call(value, field)\n                    || field === \"constructor\"\n                    || field === \"prototype\"                          )\n                    continue\n                if (   typeof fields[field] === \"undefined\"\n                    && typeof fields[\"@\"]   === \"undefined\"\n                    && errors !== null                     )\n                    errors.push(errCtx(path, `element under key \"${field}\" unexpected`))\n                if (   typeof fields[field] !== \"undefined\"\n                    && this.exec_spec(value[field], fields[field], `${path}${sep}${field}`, errors)) /*  RECURSION  */\n                    continue\n                if (   typeof fields[\"@\"] !== \"undefined\"\n                    && this.exec_spec(value[field], fields[\"@\"], `${path}${sep}${field}`, errors)) /*  RECURSION  */\n                    continue\n                valid = false\n                if (errors === null)\n                    break\n            }\n        }\n        return valid\n    },\n\n    /*  validate array type  */\n    exec_array (value, node, path, errors) {\n        let i, el\n        let valid = (typeof value === \"object\" && value instanceof Array)\n        if (!valid && errors !== null)\n            errors.push(errCtx(path, `found type \"${typeof value}\", expected array`))\n        else if (valid) {\n            let pos = 0\n            let err = null\n\n            /*  iterate over all AST nodes  */\n            for (i = 0; i < node.elements.length; i++) {\n                el = node.elements[i]\n                let found = 0\n                err = errors !== null ? [] : null\n\n                /*  iterate over remaining value elements\n                    - as long as the maximum value is not still reached and\n                    - as long as there are still elements available\n                    - as long as the elements are still valid  */\n                while (found < el.arity[1] && pos < value.length) {\n                    if (!this.exec_spec(value[pos], el.element, `${path}[${pos}]`, err))  /*  RECURSION  */\n                        break\n                    found++\n                    pos++\n                }\n                if (found < el.arity[0]) {\n                    if (errors !== null)\n                        errors.push(errCtx(`${path}[${pos}]`,\n                            `found only ${found} elements of array element type #${i}, ` +\n                            `expected at least ${el.arity[0]} elements`))\n                    valid = false\n                    break\n                }\n            }\n\n            /*  if last AST node matched not successfully, report its errors  */\n            if (!valid && err !== null && err.length > 0) {\n                if (errors !== null)\n                    err.forEach((e) => errors.push(e))\n            }\n\n            /*  in case more elements are available without matching nodes  */\n            else if (pos < value.length) {\n                if (errors !== null)\n                    errors.push(errCtx(path, `matched only ${pos} elements, ` +\n                        `but ${value.length} elements found`))\n                valid = false\n            }\n        }\n        return valid\n    },\n\n    /*  validate standard JavaScript type  */\n    exec_primary (value, node, path, errors) {\n        let valid = (node.name === \"null\" && value === null) || (typeof value === node.name)\n        if (!valid && errors !== null)\n            errors.push(errCtx(path, `found type \"${typeof value}\", expected primary type \"${node.name}\"`))\n        return valid\n    },\n\n    /*  validate custom JavaScript type  */\n    exec_class (value, node, path, errors) {\n        let type = registered(node.name)\n        let valid = (\n               typeof value === \"object\"\n            && (\n                  Object.prototype.toString.call(value) === \"[object \" + node.name + \"]\"\n               || (   typeof type === \"function\"\n                   && value instanceof type     )\n            )\n        )\n        if (!valid && errors !== null)\n            errors.push(errCtx(path, `found type \"${typeof value}\", expected class type \"${node.name}\"`))\n        return valid\n    }\n}\n\nexport { validate_execute }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport { Token } from \"./ducky-1-util.js\"\n\n/*  tokenize the validation specification  */\nvar validate_tokenize = function (spec) {\n    /*  create new Token abstraction  */\n    var token = new Token()\n    token.setName(\"validate\")\n    token.setText(spec)\n\n    /*  determine individual token symbols  */\n    let m\n    let b = 0\n    while (spec !== \"\") {\n        m = spec.match(/^(\\s*)([^{}\\[\\]:,?*+()!|\\s]+|[{}\\[\\]:,?*+()!|])(\\s*)/)\n        if (m === null)\n            throw new Error(`validate: parse error: cannot further canonicalize: \"${spec}\"`)\n        token.addToken(\n            b,\n            b + m[1].length,\n            b + m[1].length + m[2].length - 1,\n            b + m[0].length - 1,\n            m[2]\n        )\n        spec = spec.substr(m[0].length)\n        b += m[0].length\n    }\n    token.addToken(b, b, b, b, null)\n    return token\n}\n\nexport { validate_tokenize }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  internal type registry  */\nvar registry = {}\n\n/*  pre-fill type registry with JavaScript standard types  */\nlet std_types = [\n    \"Object\",  \"Boolean\", \"Number\",  \"String\",  \"Function\",\n    \"RegExp\",  \"Array\",   \"Date\",    \"Error\",\n    \"Set\",     \"Map\",     \"WeakMap\", \"Promise\", \"Proxy\", \"Iterator\"\n]\n\n/* global global: false */\nfor (let i = 0; i < std_types.length; i++)\n    if (typeof global[std_types[i]] === \"function\")\n        registry[std_types[i]] = global[std_types[i]]\n\nexport { registry }\n\n","/*\n**  Ducky -- Duck-Typed Value Handling for JavaScript\n**  Copyright (c) 2010-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*  custom Token class  */\nclass Token {\n    constructor () {\n        this.name   = \"\"\n        this.text   = \"\"\n        this.tokens = []\n        this.pos    = 0\n        this.len    = 0\n    }\n\n    /*  setter for caller context name  */\n    setName (name) {\n        this.name = name\n    }\n\n    /*  setter for plain-text input  */\n    setText (text) {\n        this.text = text\n    }\n\n    /*  setter for additional token symbols  */\n    addToken (b1, b2, e2, e1, symbol) {\n        this.tokens.push({ b1: b1, b2: b2, e2: e2, e1: e1, symbol: symbol })\n        this.len++\n    }\n\n    /*  peek at the next token or token at particular offset  */\n    peek (offset) {\n        if (typeof offset === \"undefined\")\n            offset = 0\n        if (offset >= this.len)\n            throw new Error(`${this.name}: parse error: not enough tokens`)\n        return this.tokens[this.pos + offset].symbol\n    }\n\n    /*  skip one or more tokens  */\n    skip (len) {\n        if (typeof len === \"undefined\")\n            len = 1\n        if (len > this.len)\n            throw new Error(`${this.name}: parse error: not enough tokens available to skip: ${this.ctx()}`)\n        this.pos += len\n        this.len -= len\n    }\n\n    /*  consume the current token (by expecting it to be a particular symbol)  */\n    consume (symbol) {\n        if (this.len <= 0)\n            throw new Error(`${this.name}: parse error: no more tokens available to consume: ${this.ctx()}`)\n        if (this.tokens[this.pos].symbol !== symbol)\n            throw new Error(`${this.name}: parse error: expected token symbol \"${symbol}\": ${this.ctx()}`)\n        this.pos++\n        this.len--\n    }\n\n    /*  return a textual description of the token parsing context  */\n    ctx (width) {\n        if (typeof width === \"undefined\")\n            width = 78\n        let tok = this.tokens[this.pos]\n\n        /*  the current token itself  */\n        let context = \"<\" + this.text.substr(tok.b2, tok.e2 - tok.b2 + 1) + \">\"\n        context = this.text.substr(tok.b1, tok.b2 - tok.b1) + context\n        context = context + this.text.substr(tok.e2 + 1, tok.e1 - tok.e2)\n\n        /*  the previous and following token(s)  */\n        let k = (width - context.length)\n        if (k > 0) {\n            k = Math.floor(k / 2)\n            let i, str\n            if (this.pos > 0) {\n                /*  previous token(s)  */\n                let k1 = 0\n                for (i = this.pos - 1; i >= 0; i--) {\n                    tok = this.tokens[i]\n                    str = this.text.substr(tok.b1, tok.e1 - tok.b1 + 1)\n                    k1 += str.length\n                    if (k1 > k)\n                        break\n                    context = str + context\n                }\n                if (i > 0)\n                    context = \"[...]\" + context\n            }\n            if (this.len > 1) {\n                /*  following token(s)  */\n                let k2 = 0\n                for (i = this.pos + 1; i < this.pos + this.len; i++) {\n                    tok = this.tokens[i]\n                    str = this.text.substr(tok.b1, tok.e1 - tok.b1 + 1)\n                    k2 += str.length\n                    if (k2 > k)\n                        break\n                    context = context + str\n                }\n                if (i < this.pos + this.len)\n                    context = context + \"[...]\"\n            }\n        }\n\n        /*  place everything on a single line through escape sequences  */\n        context = context.replace(/\\r/, \"\\\\r\")\n            .replace(/\\n/, \"\\\\n\")\n            .replace(/\\t/, \"\\\\t\")\n        return context\n    }\n}\n\nexport { Token }\n\n"]}